!(function(e, t) {
  'object' == typeof exports && 'undefined' != typeof module
    ? t(exports, require('react'), require('prop-types'), require('react-dom'))
    : 'function' == typeof define && define.amd
    ? define(['exports', 'react', 'prop-types', 'react-dom'], t)
    : t(((e = e || self).SortableHOC = {}), e.React, e.PropTypes, e.ReactDOM);
})(this, function(e, a, s, l) {
  'use strict';
  function t(e, t) {
    return e((t = {exports: {}}), t.exports), t.exports;
  }
  s = s && s.hasOwnProperty('default') ? s.default : s;
  var c = t(function(e) {
    function t() {
      return (
        (e.exports = t =
          Object.assign ||
          function(e) {
            for (var t = 1; t < arguments.length; t++) {
              var n = arguments[t];
              for (var o in n)
                Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o]);
            }
            return e;
          }),
        t.apply(this, arguments)
      );
    }
    e.exports = t;
  });
  var n = function(e) {
    if (Array.isArray(e)) return e;
  };
  var o = function(e, t) {
    var n = [],
      o = !0,
      r = !1,
      i = void 0;
    try {
      for (
        var a, s = e[Symbol.iterator]();
        !(o = (a = s.next()).done) && (n.push(a.value), !t || n.length !== t);
        o = !0
      );
    } catch (e) {
      (r = !0), (i = e);
    } finally {
      try {
        o || null == s.return || s.return();
      } finally {
        if (r) throw i;
      }
    }
    return n;
  };
  var r = function() {
    throw new TypeError('Invalid attempt to destructure non-iterable instance');
  };
  var b = function(e, t) {
    return n(e) || o(e, t) || r();
  };
  var u = function(e, t) {
    if (!(e instanceof t))
      throw new TypeError('Cannot call a class as a function');
  };
  function i(e, t) {
    for (var n = 0; n < t.length; n++) {
      var o = t[n];
      (o.enumerable = o.enumerable || !1),
        (o.configurable = !0),
        'value' in o && (o.writable = !0),
        Object.defineProperty(e, o.key, o);
    }
  }
  var f = function(e, t, n) {
      return t && i(e.prototype, t), n && i(e, n), e;
    },
    d = t(function(t) {
      function n(e) {
        return (n =
          'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
            ? function(e) {
                return typeof e;
              }
            : function(e) {
                return e &&
                  'function' == typeof Symbol &&
                  e.constructor === Symbol &&
                  e !== Symbol.prototype
                  ? 'symbol'
                  : typeof e;
              })(e);
      }
      function o(e) {
        return (
          'function' == typeof Symbol && 'symbol' === n(Symbol.iterator)
            ? (t.exports = o = function(e) {
                return n(e);
              })
            : (t.exports = o = function(e) {
                return e &&
                  'function' == typeof Symbol &&
                  e.constructor === Symbol &&
                  e !== Symbol.prototype
                  ? 'symbol'
                  : n(e);
              }),
          o(e)
        );
      }
      t.exports = o;
    });
  var h = function(e) {
    if (void 0 === e)
      throw new ReferenceError(
        "this hasn't been initialised - super() hasn't been called",
      );
    return e;
  };
  var p = function(e, t) {
      return !t || ('object' !== d(t) && 'function' != typeof t) ? h(e) : t;
    },
    y = t(function(t) {
      function n(e) {
        return (
          (t.exports = n = Object.setPrototypeOf
            ? Object.getPrototypeOf
            : function(e) {
                return e.__proto__ || Object.getPrototypeOf(e);
              }),
          n(e)
        );
      }
      t.exports = n;
    }),
    g = t(function(n) {
      function o(e, t) {
        return (
          (n.exports = o =
            Object.setPrototypeOf ||
            function(e, t) {
              return (e.__proto__ = t), e;
            }),
          o(e, t)
        );
      }
      n.exports = o;
    });
  var v = function(e, t) {
    if ('function' != typeof t && null !== t)
      throw new TypeError('Super expression must either be null or a function');
    (e.prototype = Object.create(t && t.prototype, {
      constructor: {value: e, writable: !0, configurable: !0},
    })),
      t && g(e, t);
  };
  var m = function(e, t, n) {
      return (
        t in e
          ? Object.defineProperty(e, t, {
              value: n,
              enumerable: !0,
              configurable: !0,
              writable: !0,
            })
          : (e[t] = n),
        e
      );
    },
    S = function(e, t, n, o, r, i, a, s) {
      if (!e) {
        var l;
        if (void 0 === t)
          l = new Error(
            'Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.',
          );
        else {
          var c = [n, o, r, i, a, s],
            u = 0;
          (l = new Error(
            t.replace(/%s/g, function() {
              return c[u++];
            }),
          )).name = 'Invariant Violation';
        }
        throw ((l.framesToPop = 1), l);
      }
    },
    x = (f(w, [
      {
        key: 'add',
        value: function(e, t) {
          this.refs[e] || (this.refs[e] = []), this.refs[e].push(t);
        },
      },
      {
        key: 'remove',
        value: function(e, t) {
          var n = this.getIndex(e, t);
          -1 !== n && this.refs[e].splice(n, 1);
        },
      },
      {
        key: 'isActive',
        value: function() {
          return this.active;
        },
      },
      {
        key: 'getActive',
        value: function() {
          var t = this;
          return this.refs[this.active.collection].find(function(e) {
            return e.node.sortableInfo.index == t.active.index;
          });
        },
      },
      {
        key: 'getIndex',
        value: function(e, t) {
          return this.refs[e].indexOf(t);
        },
      },
      {
        key: 'getOrderedRefs',
        value: function(e) {
          var t =
            0 < arguments.length && void 0 !== e ? e : this.active.collection;
          return this.refs[t].sort(O);
        },
      },
    ]),
    w);
  function w() {
    u(this, w), m(this, 'refs', {});
  }
  function O(e, t) {
    return e.node.sortableInfo.index - t.node.sortableInfo.index;
  }
  var T = function(e) {
    if (Array.isArray(e)) {
      for (var t = 0, n = new Array(e.length); t < e.length; t++) n[t] = e[t];
      return n;
    }
  };
  var C = function(e) {
    if (
      Symbol.iterator in Object(e) ||
      '[object Arguments]' === Object.prototype.toString.call(e)
    )
      return Array.from(e);
  };
  var k = function() {
    throw new TypeError('Invalid attempt to spread non-iterable instance');
  };
  var I = function(e) {
    return T(e) || C(e) || k();
  };
  function E(n) {
    for (
      var e = arguments.length, o = new Array(1 < e ? e - 1 : 0), t = 1;
      t < e;
      t++
    )
      o[t - 1] = arguments[t];
    return Object.keys(n).reduce(function(e, t) {
      return -1 === o.indexOf(t) && (e[t] = n[t]), e;
    }, {});
  }
  var D = {
      end: ['touchend', 'touchcancel', 'mouseup'],
      move: ['touchmove', 'mousemove'],
      start: ['touchstart', 'mousedown'],
    },
    R = (function() {
      if ('undefined' == typeof window || 'undefined' == typeof document)
        return '';
      var e = window.getComputedStyle(document.documentElement, '') || [
          '-moz-hidden-iframe',
        ],
        t = (Array.prototype.slice
          .call(e)
          .join('')
          .match(/-(moz|webkit|ms)-/) ||
          ('' === e.OLink && ['', 'o']))[1];
      switch (t) {
        case 'ms':
          return 'ms';
        default:
          return t && t.length ? t[0].toUpperCase() + t.substr(1) : '';
      }
    })();
  function N(t, n) {
    Object.keys(n).forEach(function(e) {
      t.style[e] = n[e];
    });
  }
  function A(e, t) {
    e.style[''.concat(R, 'Transform')] =
      null == t ? '' : 'translate3d('.concat(t.x, 'px,').concat(t.y, 'px,0)');
  }
  function M(e, t) {
    e.style[''.concat(R, 'TransitionDuration')] =
      null == t ? '' : ''.concat(t, 'ms');
  }
  function P(e, t) {
    for (; e; ) {
      if (t(e)) return e;
      e = e.parentNode;
    }
    return null;
  }
  function j(e, t, n) {
    return Math.max(e, Math.min(n, t));
  }
  function W(e) {
    return 'px' === e.substr(-2) ? parseFloat(e) : 0;
  }
  function L(e, t) {
    var n = t.displayName || t.name;
    return n ? ''.concat(e, '(').concat(n, ')') : e;
  }
  function H(e, t) {
    var n = e.getBoundingClientRect();
    return {top: n.top + t.top, left: n.left + t.left};
  }
  function K(e) {
    return e.touches && e.touches.length
      ? {x: e.touches[0].pageX, y: e.touches[0].pageY}
      : e.changedTouches && e.changedTouches.length
      ? {x: e.changedTouches[0].pageX, y: e.changedTouches[0].pageY}
      : {x: e.pageX, y: e.pageY};
  }
  function _(e, t, n) {
    var o = 2 < arguments.length && void 0 !== n ? n : {left: 0, top: 0};
    if (e) {
      var r = {left: o.left + e.offsetLeft, top: o.top + e.offsetTop};
      return e.parentNode === t ? r : _(e.parentNode, t, r);
    }
  }
  function B(e) {
    var t = e.lockOffset,
      n = e.width,
      o = e.height,
      r = t,
      i = t,
      a = 'px';
    if ('string' == typeof t) {
      var s = /^[+-]?\d*(?:\.\d*)?(px|%)$/.exec(t);
      S(
        null !== s,
        'lockOffset value should be a number or a string of a number followed by "px" or "%". Given %s',
        t,
      ),
        (r = parseFloat(t)),
        (i = parseFloat(t)),
        (a = s[1]);
    }
    return (
      S(
        isFinite(r) && isFinite(i),
        'lockOffset value should be a finite. Given %s',
        t,
      ),
      '%' === a && ((r = (r * n) / 100), (i = (i * o) / 100)),
      {x: r, y: i}
    );
  }
  function F(e) {
    return e instanceof HTMLElement
      ? (function(e) {
          var t = window.getComputedStyle(e),
            n = /(auto|scroll)/;
          return ['overflow', 'overflowX', 'overflowY'].find(function(e) {
            return n.test(t[e]);
          });
        })(e)
        ? e
        : F(e.parentNode)
      : null;
  }
  var G = 27,
    X = 32,
    U = 37,
    Y = 38,
    q = 39,
    z = 40,
    V = {
      Anchor: 'A',
      Button: 'BUTTON',
      Canvas: 'CANVAS',
      Input: 'INPUT',
      Option: 'OPTION',
      Textarea: 'TEXTAREA',
      Select: 'SELECT',
    };
  function $(t) {
    var e,
      n,
      o,
      r =
        1 < arguments.length && void 0 !== arguments[1]
          ? arguments[1]
          : {withRef: !1};
    return (
      (o = a.Component),
      v(i, o),
      f(i, [
        {
          key: 'componentDidMount',
          value: function() {
            l.findDOMNode(this).sortableHandle = !0;
          },
        },
        {
          key: 'getWrappedInstance',
          value: function() {
            return (
              S(
                r.withRef,
                'To access the wrapped instance, you need to pass in {withRef: true} as the second argument of the SortableHandle() call',
              ),
              this.refs.wrappedInstance
            );
          },
        },
        {
          key: 'render',
          value: function() {
            var e = r.withRef ? 'wrappedInstance' : null;
            return a.createElement(t, c({ref: e}, this.props));
          },
        },
      ]),
      (n = e = i),
      m(e, 'displayName', L('sortableHandle', t)),
      n
    );
    function i() {
      return u(this, i), p(this, y(i).apply(this, arguments));
    }
  }
  function J(e) {
    return null != e.sortableHandle;
  }
  var Q = (f(Z, [
    {
      key: 'clear',
      value: function() {
        clearInterval(this.interval), (this.interval = null);
      },
    },
    {
      key: 'update',
      value: function(e) {
        var t = this,
          n = e.translate,
          o = e.minTranslate,
          r = e.maxTranslate,
          i = e.width,
          a = e.height,
          s = {x: 0, y: 0},
          l = {x: 1, y: 1},
          c = 10,
          u = 10,
          f = this.container,
          d = f.scrollTop,
          h = f.scrollLeft,
          p = f.scrollHeight,
          y = f.scrollWidth,
          g = 0 === d,
          v = p - d - f.clientHeight == 0,
          m = 0 === h,
          x = y - h - f.clientWidth == 0;
        n.y >= r.y - a / 2 && !v
          ? ((s.y = 1), (l.y = u * Math.abs((r.y - a / 2 - n.y) / a)))
          : n.x >= r.x - i / 2 && !x
          ? ((s.x = 1), (l.x = c * Math.abs((r.x - i / 2 - n.x) / i)))
          : n.y <= o.y + a / 2 && !g
          ? ((s.y = -1), (l.y = u * Math.abs((n.y - a / 2 - o.y) / a)))
          : n.x <= o.x + i / 2 &&
            !m &&
            ((s.x = -1), (l.x = c * Math.abs((n.x - i / 2 - o.x) / i))),
          this.interval && (this.clear(), (this.isAutoScrolling = !1)),
          (0 === s.x && 0 === s.y) ||
            (this.interval = setInterval(function() {
              t.isAutoScrolling = !0;
              var e = {left: l.x * s.x, top: l.y * s.y};
              (t.container.scrollTop += e.top),
                (t.container.scrollLeft += e.left),
                t.onScrollCallback(e);
            }, 5));
      },
    },
  ]),
  Z);
  function Z(e, t) {
    u(this, Z), (this.container = e), (this.onScrollCallback = t);
  }
  var ee = {
      axis: s.oneOf(['x', 'y', 'xy']),
      contentWindow: s.any,
      disableAutoscroll: s.bool,
      distance: s.number,
      getContainer: s.func,
      getHelperDimensions: s.func,
      helperClass: s.string,
      helperContainer: s.oneOfType([
        s.func,
        'undefined' == typeof HTMLElement ? s.any : s.instanceOf(HTMLElement),
      ]),
      hideSortableGhost: s.bool,
      keyboardSortingTransitionDuration: s.number,
      lockAxis: s.string,
      lockOffset: s.oneOfType([
        s.number,
        s.string,
        s.arrayOf(s.oneOfType([s.number, s.string])),
      ]),
      lockToContainerEdges: s.bool,
      onSortEnd: s.func,
      onSortMove: s.func,
      onSortOver: s.func,
      onSortStart: s.func,
      pressDelay: s.number,
      pressThreshold: s.number,
      shouldCancelStart: s.func,
      transitionDuration: s.number,
      updateBeforeSortStart: s.func,
      useDragHandle: s.bool,
      useWindowAsScrollContainer: s.bool,
      zoomFactor: s.number,
    },
    te = {
      axis: 'y',
      disableAutoscroll: !1,
      distance: 0,
      getHelperDimensions: function(e) {
        var t = e.node;
        return {height: t.offsetHeight, width: t.offsetWidth};
      },
      hideSortableGhost: !0,
      lockOffset: '50%',
      lockToContainerEdges: !1,
      pressDelay: 0,
      pressThreshold: 5,
      shouldCancelStart: function(e) {
        return (
          -1 !==
            [V.Input, V.Textarea, V.Select, V.Option, V.Button].indexOf(
              e.target.tagName,
            ) ||
          !!P(e.target, function(e) {
            return 'true' === e.contentEditable;
          })
        );
      },
      transitionDuration: 300,
      useWindowAsScrollContainer: !1,
      zoomFactor: 1,
    },
    ne = Object.keys(ee);
  function oe(t, e) {
    var n = Object.keys(t);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(t);
      e &&
        (o = o.filter(function(e) {
          return Object.getOwnPropertyDescriptor(t, e).enumerable;
        })),
        n.push.apply(n, o);
    }
    return n;
  }
  function re(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = null != arguments[e] ? arguments[e] : {};
      e % 2
        ? oe(n, !0).forEach(function(e) {
            m(t, e, n[e]);
          })
        : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
        : oe(n).forEach(function(e) {
            Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e));
          });
    }
    return t;
  }
  function ie(t) {
    var e,
      n,
      o,
      r =
        1 < arguments.length && void 0 !== arguments[1]
          ? arguments[1]
          : {withRef: !1};
    return (
      (o = a.Component),
      v(i, o),
      f(i, [
        {
          key: 'getChildContext',
          value: function() {
            return {manager: this.manager};
          },
        },
        {
          key: 'componentDidMount',
          value: function() {
            var n = this,
              o = this.props.useWindowAsScrollContainer,
              e = this.getContainer();
            Promise.resolve(e).then(function(e) {
              (n.container = e),
                (n.document = n.container.ownerDocument || document);
              var t = n.props.contentWindow || n.document.defaultView || window;
              (n.contentWindow = 'function' == typeof t ? t() : t),
                (n.scrollContainer = o
                  ? n.document.scrollingElement || n.document.documentElement
                  : F(n.container) || n.container),
                (n.autoScroller = new Q(n.scrollContainer, n.onAutoScroll)),
                Object.keys(n.events).forEach(function(t) {
                  return D[t].forEach(function(e) {
                    return n.container.addEventListener(e, n.events[t], !1);
                  });
                }),
                n.container.addEventListener('keydown', n.handleKeyDown);
            });
          },
        },
        {
          key: 'componentWillUnmount',
          value: function() {
            var n = this;
            this.helper &&
              this.helper.parentNode &&
              this.helper.parentNode.removeChild(this.helper),
              this.container &&
                (Object.keys(this.events).forEach(function(t) {
                  return D[t].forEach(function(e) {
                    return n.container.removeEventListener(e, n.events[t]);
                  });
                }),
                this.container.removeEventListener(
                  'keydown',
                  this.handleKeyDown,
                ));
          },
        },
        {
          key: 'updateHelperPosition',
          value: function(e) {
            var t = this.props,
              n = t.lockAxis,
              o = t.lockOffset,
              r = t.lockToContainerEdges,
              i = t.transitionDuration,
              a = t.keyboardSortingTransitionDuration,
              s = void 0 === a ? i : a,
              l = this.manager.isKeySorting,
              c = e.ignoreTransition,
              u = K(e),
              f = {
                x: u.x - this.initialOffset.x,
                y: u.y - this.initialOffset.y,
              };
            if (
              ((f.y -= window.pageYOffset - this.initialWindowScroll.top),
              (f.x -= window.pageXOffset - this.initialWindowScroll.left),
              (this.translate = f),
              r)
            ) {
              var d = (function(e) {
                  var t = e.height,
                    n = e.width,
                    o = e.lockOffset,
                    r = Array.isArray(o) ? o : [o, o];
                  S(
                    2 === r.length,
                    'lockOffset prop of SortableContainer should be a single value or an array of exactly two values. Given %s',
                    o,
                  );
                  var i = b(r, 2),
                    a = i[0],
                    s = i[1];
                  return [
                    B({height: t, lockOffset: a, width: n}),
                    B({height: t, lockOffset: s, width: n}),
                  ];
                })({height: this.height, lockOffset: o, width: this.width}),
                h = b(d, 2),
                p = h[0],
                y = h[1],
                g = this.width / 2 - p.x,
                v = this.height / 2 - p.y,
                m = this.width / 2 - y.x,
                x = this.height / 2 - y.y;
              (f.x = j(this.minTranslate.x + g, this.maxTranslate.x - m, f.x)),
                (f.y = j(
                  this.minTranslate.y + v,
                  this.maxTranslate.y - x,
                  f.y,
                ));
            }
            'x' === n ? (f.y = 0) : 'y' === n && (f.x = 0),
              l && s && !c && M(this.helper, s),
              A(this.helper, f);
          },
        },
        {
          key: 'animateNodes',
          value: function() {
            var e = this.props,
              t = e.transitionDuration,
              n = e.hideSortableGhost,
              o = e.onSortOver,
              r = e.zoomFactor,
              i = this.containerScrollDelta,
              a = this.windowScrollDelta,
              s = this.manager.getOrderedRefs(),
              l = this.offsetEdge.left + this.translate.x + i.left,
              c = this.offsetEdge.top + this.translate.y + i.top,
              u = this.manager.isKeySorting,
              f = this.newIndex;
            this.newIndex = null;
            for (var d = 0, h = s.length; d < h; d++) {
              var p = s[d].node,
                y = p.sortableInfo.index,
                g = p.offsetWidth,
                v = p.offsetHeight,
                m = this.height > v ? v / 2 : this.height / 2,
                x = this.width > g ? g / 2 : this.width / 2,
                b = u && y > this.index && y <= f,
                w = u && y < this.index && f <= y,
                S = {x: 0, y: 0},
                O = s[d].edgeOffset;
              O ||
                ((O = _(p, this.container)),
                (s[d].edgeOffset = O),
                u && (s[d].boundingClientRect = H(p, i)));
              var T = d < s.length - 1 && s[d + 1],
                C = 0 < d && s[d - 1];
              T &&
                !T.edgeOffset &&
                ((T.edgeOffset = _(T.node, this.container)),
                u && (T.boundingClientRect = H(T.node, i))),
                y !== this.index
                  ? (t && M(p, t),
                    this.axis.x
                      ? this.axis.y
                        ? w ||
                          (y < this.index &&
                            ((l + a.left - x <= O.left &&
                              c + a.top <= O.top + m) ||
                              c + a.top + m <= O.top))
                          ? ((S.x = this.width + this.marginOffset.x),
                            O.left + S.x >
                              this.containerBoundingRect.width - x &&
                              T &&
                              ((S.x = T.edgeOffset.left - O.left),
                              (S.y = T.edgeOffset.top - O.top)),
                            null === this.newIndex && (this.newIndex = y))
                          : (b ||
                              (y > this.index &&
                                ((l + a.left + x >= O.left &&
                                  c + a.top + m >= O.top) ||
                                  c + a.top + m >= O.top + v))) &&
                            ((S.x = -(this.width + this.marginOffset.x)),
                            O.left + S.x <
                              this.containerBoundingRect.left + x &&
                              C &&
                              ((S.x = C.edgeOffset.left - O.left),
                              (S.y = C.edgeOffset.top - O.top)),
                            (this.newIndex = y))
                        : b || (y > this.index && l + a.left + x >= O.left)
                        ? ((S.x = -(this.width * r + this.marginOffset.x)),
                          (this.newIndex = y))
                        : (w || (y < this.index && l + a.left <= O.left + x)) &&
                          ((S.x = this.width * r + this.marginOffset.x),
                          null == this.newIndex && (this.newIndex = y))
                      : this.axis.y &&
                        (b || (y > this.index && c + a.top + m >= O.top)
                          ? ((S.y = -(this.height * r + this.marginOffset.y)),
                            (this.newIndex = y))
                          : (w || (y < this.index && c + a.top <= O.top + m)) &&
                            ((S.y = this.height * r + this.marginOffset.y),
                            null == this.newIndex && (this.newIndex = y))),
                    A(p, S),
                    (s[d].translate = S))
                  : n &&
                    N((this.sortableGhost = p), {
                      opacity: 0,
                      visibility: 'hidden',
                    });
            }
            null == this.newIndex && (this.newIndex = this.index),
              u && (this.newIndex = f);
            var k = u ? this.prevIndex : f;
            o &&
              this.newIndex !== k &&
              o({
                collection: this.manager.active.collection,
                index: this.index,
                newIndex: this.newIndex,
                oldIndex: k,
                isKeySorting: u,
              });
          },
        },
        {
          key: 'getWrappedInstance',
          value: function() {
            return (
              S(
                r.withRef,
                'To access the wrapped instance, you need to pass in {withRef: true} as the second argument of the SortableContainer() call',
              ),
              this.refs.wrappedInstance
            );
          },
        },
        {
          key: 'getContainer',
          value: function() {
            var e = this.props.getContainer;
            return 'function' != typeof e
              ? l.findDOMNode(this)
              : e(r.withRef ? this.getWrappedInstance() : void 0);
          },
        },
        {
          key: 'render',
          value: function() {
            var e = r.withRef ? 'wrappedInstance' : null;
            return a.createElement(t, c({ref: e}, E(this.props, ne)));
          },
        },
        {
          key: 'helperContainer',
          get: function() {
            var e = this.props.helperContainer;
            return 'function' == typeof e
              ? e()
              : this.props.helperContainer || this.document.body;
          },
        },
        {
          key: 'containerScrollDelta',
          get: function() {
            return this.props.useWindowAsScrollContainer
              ? {left: 0, top: 0}
              : {
                  left:
                    this.scrollContainer.scrollLeft - this.initialScroll.left,
                  top: this.scrollContainer.scrollTop - this.initialScroll.top,
                };
          },
        },
        {
          key: 'windowScrollDelta',
          get: function() {
            return {
              left:
                this.contentWindow.pageXOffset - this.initialWindowScroll.left,
              top:
                this.contentWindow.pageYOffset - this.initialWindowScroll.top,
            };
          },
        },
      ]),
      (n = e = i),
      m(e, 'displayName', L('sortableList', t)),
      m(e, 'defaultProps', te),
      m(e, 'propTypes', ee),
      m(e, 'childContextTypes', {manager: s.object.isRequired}),
      n
    );
    function i(e) {
      var w;
      return (
        u(this, i),
        (w = p(this, y(i).call(this, e))),
        m(h(w), 'handleStart', function(e) {
          var t = w.props,
            n = t.distance,
            o = t.shouldCancelStart;
          if (2 !== e.button && !o(e)) {
            (w.touched = !0), (w.position = K(e));
            var r = P(e.target, function(e) {
              return null != e.sortableInfo;
            });
            if (r && r.sortableInfo && w.nodeIsChild(r) && !w.state.sorting) {
              var i = w.props.useDragHandle,
                a = r.sortableInfo,
                s = a.index,
                l = a.collection;
              if (a.disabled) return;
              if (i && !P(e.target, J)) return;
              (w.manager.active = {collection: l, index: s}),
                (function(e) {
                  return (
                    (e.touches && e.touches.length) ||
                    (e.changedTouches && e.changedTouches.length)
                  );
                })(e) ||
                  e.target.tagName !== V.Anchor ||
                  e.preventDefault(),
                n ||
                  (0 === w.props.pressDelay
                    ? w.handlePress(e)
                    : (w.pressTimer = setTimeout(function() {
                        return w.handlePress(e);
                      }, w.props.pressDelay)));
            }
          }
        }),
        m(h(w), 'nodeIsChild', function(e) {
          return e.sortableInfo.manager === w.manager;
        }),
        m(h(w), 'handleMove', function(e) {
          var t = w.props,
            n = t.distance,
            o = t.pressThreshold;
          if (
            !w.state.sorting &&
            w.touched &&
            !w._awaitingUpdateBeforeSortStart
          ) {
            var r = K(e),
              i = {x: w.position.x - r.x, y: w.position.y - r.y},
              a = Math.abs(i.x) + Math.abs(i.y);
            (w.delta = i),
              n || (o && !(o <= a))
                ? n && n <= a && w.manager.isActive() && w.handlePress(e)
                : (clearTimeout(w.cancelTimer),
                  (w.cancelTimer = setTimeout(w.cancel, 0)));
          }
        }),
        m(h(w), 'handleEnd', function() {
          (w.touched = !1), w.cancel();
        }),
        m(h(w), 'cancel', function() {
          var e = w.props.distance;
          w.state.sorting ||
            (e || clearTimeout(w.pressTimer), (w.manager.active = null));
        }),
        m(h(w), 'handlePress', function(b) {
          try {
            var r = w.manager.getActive(),
              e = (function() {
                if (r) {
                  var e = function() {
                      var e = v.sortableInfo.index,
                        t = (function(e) {
                          var t = window.getComputedStyle(e);
                          return {
                            bottom: W(t.marginBottom),
                            left: W(t.marginLeft),
                            right: W(t.marginRight),
                            top: W(t.marginTop),
                          };
                        })(v),
                        n = w.scrollContainer.getBoundingClientRect(),
                        o = f({collection: m, index: e, node: v});
                      if (
                        ((w.node = v),
                        (w.margin = t),
                        (w.width = o.width / g),
                        (w.height = o.height / g),
                        (w.marginOffset = {
                          x: w.margin.left + w.margin.right,
                          y: Math.max(w.margin.top, w.margin.bottom),
                        }),
                        (w.boundingClientRect = v.getBoundingClientRect()),
                        (w.containerBoundingRect = n),
                        (w.index = e),
                        (w.newIndex = e),
                        (w.axis = {
                          x: 0 <= u.indexOf('x'),
                          y: 0 <= u.indexOf('y'),
                        }),
                        (w.offsetEdge = _(v, w.container)),
                        (w.initialOffset = K(
                          x
                            ? re({}, b, {
                                pageX: w.boundingClientRect.left,
                                pageY: w.boundingClientRect.top,
                              })
                            : b,
                        )),
                        (w.initialScroll = {
                          left: w.scrollContainer.scrollLeft,
                          top: w.scrollContainer.scrollTop,
                        }),
                        (w.initialWindowScroll = {
                          left: window.pageXOffset,
                          top: window.pageYOffset,
                        }),
                        (w.helper = w.helperContainer.appendChild(
                          (function(e) {
                            var t =
                                'input, textarea, select, canvas, [contenteditable]',
                              n = e.querySelectorAll(t),
                              o = e.cloneNode(!0);
                            return (
                              I(o.querySelectorAll(t)).forEach(function(e, t) {
                                'file' !== e.type && (e.value = n[t].value),
                                  'radio' === e.type &&
                                    e.name &&
                                    (e.name = '__sortableClone__'.concat(
                                      e.name,
                                    )),
                                  e.tagName === V.Canvas &&
                                    0 < n[t].width &&
                                    0 < n[t].height &&
                                    e.getContext('2d').drawImage(n[t], 0, 0);
                              }),
                              o
                            );
                          })(v),
                        )),
                        N(w.helper, {
                          boxSizing: 'border-box',
                          height: ''.concat(w.height, 'px'),
                          left: ''.concat(
                            w.boundingClientRect.left - t.left,
                            'px',
                          ),
                          pointerEvents: 'none',
                          position: 'fixed',
                          top: ''.concat(
                            w.boundingClientRect.top - t.top,
                            'px',
                          ),
                          width: ''.concat(w.width, 'px'),
                        }),
                        x && w.helper.focus(),
                        h &&
                          N((w.sortableGhost = v), {
                            opacity: 0,
                            visibility: 'hidden',
                          }),
                        (w.minTranslate = {}),
                        (w.maxTranslate = {}),
                        x)
                      ) {
                        var r = y
                            ? {
                                top: 0,
                                left: 0,
                                width: w.contentWindow.innerWidth,
                                height: w.contentWindow.innerHeight,
                              }
                            : w.containerBoundingRect,
                          i = r.top,
                          a = r.left,
                          s = r.width,
                          l = i + r.height,
                          c = a + s;
                        w.axis.x &&
                          ((w.minTranslate.x = a - w.boundingClientRect.left),
                          (w.maxTranslate.x =
                            c - (w.boundingClientRect.left + w.width))),
                          w.axis.y &&
                            ((w.minTranslate.y = i - w.boundingClientRect.top),
                            (w.maxTranslate.y =
                              l - (w.boundingClientRect.top + w.height)));
                      } else
                        w.axis.x &&
                          ((w.minTranslate.x =
                            (y ? 0 : n.left) -
                            w.boundingClientRect.left -
                            w.width / 2),
                          (w.maxTranslate.x =
                            (y
                              ? w.contentWindow.innerWidth
                              : n.left + n.width) -
                            w.boundingClientRect.left -
                            w.width / 2)),
                          w.axis.y &&
                            ((w.minTranslate.y =
                              (y ? 0 : n.top) -
                              w.boundingClientRect.top -
                              w.height / 2),
                            (w.maxTranslate.y =
                              (y
                                ? w.contentWindow.innerHeight
                                : n.top + n.height) -
                              w.boundingClientRect.top -
                              w.height / 2));
                      d &&
                        d.split(' ').forEach(function(e) {
                          return w.helper.classList.add(e);
                        }),
                        (w.listenerNode = b.touches ? v : w.contentWindow),
                        x
                          ? (w.listenerNode.addEventListener(
                              'wheel',
                              w.handleKeyEnd,
                              !0,
                            ),
                            w.listenerNode.addEventListener(
                              'mousedown',
                              w.handleKeyEnd,
                              !0,
                            ),
                            w.listenerNode.addEventListener(
                              'keydown',
                              w.handleKeyDown,
                            ))
                          : (D.move.forEach(function(e) {
                              return w.listenerNode.addEventListener(
                                e,
                                w.handleSortMove,
                                !1,
                              );
                            }),
                            D.end.forEach(function(e) {
                              return w.listenerNode.addEventListener(
                                e,
                                w.handleSortEnd,
                                !1,
                              );
                            })),
                        w.setState({sorting: !0, sortingIndex: e}),
                        p &&
                          p(
                            {node: v, index: e, collection: m, isKeySorting: x},
                            b,
                          ),
                        x && w.keyMove(0);
                    },
                    t = w.props,
                    u = t.axis,
                    f = t.getHelperDimensions,
                    d = t.helperClass,
                    h = t.hideSortableGhost,
                    n = t.updateBeforeSortStart,
                    p = t.onSortStart,
                    y = t.useWindowAsScrollContainer,
                    g = t.zoomFactor,
                    v = r.node,
                    m = r.collection,
                    x = w.manager.isKeySorting,
                    o = (function() {
                      if ('function' == typeof n) {
                        w._awaitingUpdateBeforeSortStart = !0;
                        var e = (function(e, t) {
                          try {
                            var n = e();
                          } catch (e) {
                            return t(!0, e);
                          }
                          return n && n.then
                            ? n.then(t.bind(null, !1), t.bind(null, !0))
                            : t(!1, value);
                        })(
                          function() {
                            var e = v.sortableInfo.index;
                            return Promise.resolve(
                              n(
                                {
                                  collection: m,
                                  index: e,
                                  node: v,
                                  isKeySorting: x,
                                },
                                b,
                              ),
                            ).then(function() {});
                          },
                          function(e, t) {
                            if (((w._awaitingUpdateBeforeSortStart = !1), e))
                              throw t;
                            return t;
                          },
                        );
                        if (e && e.then) return e.then(function() {});
                      }
                    })();
                  return o && o.then ? o.then(e) : e();
                }
              })();
            return Promise.resolve(
              e && e.then ? e.then(function() {}) : void 0,
            );
          } catch (e) {
            return Promise.reject(e);
          }
        }),
        m(h(w), 'handleSortMove', function(e) {
          var t = w.props.onSortMove;
          'function' == typeof e.preventDefault && e.preventDefault(),
            w.updateHelperPosition(e),
            w.animateNodes(),
            w.autoscroll(),
            t && t(e);
        }),
        m(h(w), 'handleSortEnd', function(e) {
          var t = w.props,
            n = t.hideSortableGhost,
            o = t.onSortEnd,
            r = w.manager,
            i = r.active.collection,
            a = r.isKeySorting,
            s = w.manager.refs[i];
          w.listenerNode &&
            (a
              ? (w.listenerNode.removeEventListener(
                  'wheel',
                  w.handleKeyEnd,
                  !0,
                ),
                w.listenerNode.removeEventListener(
                  'mousedown',
                  w.handleKeyEnd,
                  !0,
                ),
                w.listenerNode.removeEventListener('keydown', w.handleKeyDown))
              : (D.move.forEach(function(e) {
                  return w.listenerNode.removeEventListener(
                    e,
                    w.handleSortMove,
                  );
                }),
                D.end.forEach(function(e) {
                  return w.listenerNode.removeEventListener(e, w.handleSortEnd);
                }))),
            w.helper.parentNode.removeChild(w.helper),
            n &&
              w.sortableGhost &&
              N(w.sortableGhost, {opacity: '', visibility: ''});
          for (var l = 0, c = s.length; l < c; l++) {
            var u = s[l],
              f = u.node;
            (u.edgeOffset = null),
              A(f, (u.boundingClientRect = null)),
              M(f, null),
              (u.translate = null);
          }
          w.autoScroller.clear(),
            (w.manager.active = null),
            (w.manager.isKeySorting = !1),
            w.setState({sorting: !1, sortingIndex: null}),
            'function' == typeof o &&
              o(
                {
                  collection: i,
                  newIndex: w.newIndex,
                  oldIndex: w.index,
                  isKeySorting: a,
                },
                e,
              ),
            (w.touched = !1);
        }),
        m(h(w), 'autoscroll', function() {
          var e = w.props.disableAutoscroll,
            t = w.manager.isKeySorting;
          if (!e) {
            if (t) {
              var n = re({}, w.translate),
                o = 0,
                r = 0;
              return (
                w.axis.x &&
                  ((n.x = Math.min(
                    w.maxTranslate.x,
                    Math.max(w.minTranslate.x, w.translate.x),
                  )),
                  (o = w.translate.x - n.x)),
                w.axis.y &&
                  ((n.y = Math.min(
                    w.maxTranslate.y,
                    Math.max(w.minTranslate.y, w.translate.y),
                  )),
                  (r = w.translate.y - n.y)),
                (w.translate = n),
                A(w.helper, w.translate),
                (w.scrollContainer.scrollLeft += o),
                void (w.scrollContainer.scrollTop += r)
              );
            }
            w.autoScroller.update({
              height: w.height,
              maxTranslate: w.maxTranslate,
              minTranslate: w.minTranslate,
              translate: w.translate,
              width: w.width,
            });
          }
        }),
        m(h(w), 'onAutoScroll', function(e) {
          (w.translate.x += e.left), (w.translate.y += e.top), w.animateNodes();
        }),
        m(h(w), 'handleKeyDown', function(e) {
          var t = e.keyCode,
            n = w.props.shouldCancelStart;
          if (
            (!w.manager.active || w.manager.isKeySorting) &&
            (w.manager.active ||
              (t === X && !n(e) && w.isValidSortingTarget(e)))
          )
            switch ((e.stopPropagation(), e.preventDefault(), t)) {
              case X:
                w.manager.active ? w.keyDrop(e) : w.keyLift(e);
                break;
              case z:
              case q:
                w.keyMove(1);
                break;
              case Y:
              case U:
                w.keyMove(-1);
                break;
              case G:
                (w.newIndex = w.manager.active.index), w.keyDrop(e);
            }
        }),
        m(h(w), 'keyLift', function(e) {
          var t = e.target,
            n = P(t, function(e) {
              return null != e.sortableInfo;
            }).sortableInfo,
            o = n.index,
            r = n.collection;
          (w.initialFocusedNode = t),
            (w.manager.isKeySorting = !0),
            (w.manager.active = {index: o, collection: r}),
            w.handlePress(e);
        }),
        m(h(w), 'keyMove', function(e) {
          var t = w.manager.getOrderedRefs(),
            n = t[t.length - 1].node.sortableInfo.index,
            o = w.newIndex + e,
            r = w.newIndex;
          if (!(o < 0 || n < o)) {
            (w.prevIndex = r), (w.newIndex = o);
            var i = (function(e, t, n) {
                return e < n && t < e ? e - 1 : n < e && e < t ? e + 1 : e;
              })(w.newIndex, w.prevIndex, w.index),
              a = t.find(function(e) {
                return e.node.sortableInfo.index === i;
              }),
              s = a.node,
              l = w.containerScrollDelta,
              c = a.boundingClientRect || H(s, l),
              u = a.translate || {x: 0, y: 0},
              f = c.top + u.y - l.top,
              d = c.left + u.x - l.left,
              h = r < o,
              p = h && w.axis.x ? s.offsetWidth - w.width : 0,
              y = h && w.axis.y ? s.offsetHeight - w.height : 0;
            w.handleSortMove({
              pageX: d + p,
              pageY: f + y,
              ignoreTransition: 0 === e,
            });
          }
        }),
        m(h(w), 'keyDrop', function(e) {
          w.handleSortEnd(e),
            w.initialFocusedNode && w.initialFocusedNode.focus();
        }),
        m(h(w), 'handleKeyEnd', function(e) {
          w.manager.active && w.keyDrop(e);
        }),
        m(h(w), 'isValidSortingTarget', function(e) {
          var t = w.props.useDragHandle,
            n = e.target,
            o = P(n, function(e) {
              return null != e.sortableInfo;
            });
          return (
            o &&
            o.sortableInfo &&
            !o.sortableInfo.disabled &&
            (t ? J(n) : n.sortableInfo)
          );
        }),
        (function(e) {
          S(
            !(e.distance && e.pressDelay),
            'Attempted to set both `pressDelay` and `distance` on SortableContainer, you may only use one or the other, not both at the same time.',
          );
        })(e),
        (w.state = {}),
        (w.manager = new x()),
        (w.events = {
          end: w.handleEnd,
          move: w.handleMove,
          start: w.handleStart,
        }),
        w
      );
    }
  }
  var ae = {
      index: s.number.isRequired,
      collection: s.oneOfType([s.number, s.string]),
      disabled: s.bool,
    },
    se = Object.keys(ae);
  function le(t) {
    var e,
      n,
      o,
      r =
        1 < arguments.length && void 0 !== arguments[1]
          ? arguments[1]
          : {withRef: !1};
    return (
      (o = a.Component),
      v(i, o),
      f(i, [
        {
          key: 'componentDidMount',
          value: function() {
            this.register();
          },
        },
        {
          key: 'componentDidUpdate',
          value: function(e) {
            this.node &&
              (e.index !== this.props.index &&
                (this.node.sortableInfo.index = this.props.index),
              e.disabled !== this.props.disabled &&
                (this.node.sortableInfo.disabled = this.props.disabled)),
              e.collection !== this.props.collection &&
                (this.unregister(e.collection), this.register());
          },
        },
        {
          key: 'componentWillUnmount',
          value: function() {
            this.unregister();
          },
        },
        {
          key: 'register',
          value: function() {
            var e = this.props,
              t = e.collection,
              n = e.disabled,
              o = e.index,
              r = l.findDOMNode(this);
            (r.sortableInfo = {
              collection: t,
              disabled: n,
              index: o,
              manager: this.context.manager,
            }),
              (this.node = r),
              (this.ref = {node: r}),
              this.context.manager.add(t, this.ref);
          },
        },
        {
          key: 'unregister',
          value: function(e) {
            var t =
              0 < arguments.length && void 0 !== e ? e : this.props.collection;
            this.context.manager.remove(t, this.ref);
          },
        },
        {
          key: 'getWrappedInstance',
          value: function() {
            return (
              S(
                r.withRef,
                'To access the wrapped instance, you need to pass in {withRef: true} as the second argument of the SortableElement() call',
              ),
              this.refs.wrappedInstance
            );
          },
        },
        {
          key: 'render',
          value: function() {
            var e = r.withRef ? 'wrappedInstance' : null;
            return a.createElement(t, c({ref: e}, E(this.props, se)));
          },
        },
      ]),
      (n = e = i),
      m(e, 'displayName', L('sortableElement', t)),
      m(e, 'contextTypes', {manager: s.object.isRequired}),
      m(e, 'propTypes', ae),
      m(e, 'defaultProps', {collection: 0}),
      n
    );
    function i() {
      return u(this, i), p(this, y(i).apply(this, arguments));
    }
  }
  (e.SortableContainer = ie),
    (e.sortableContainer = ie),
    (e.SortableElement = le),
    (e.sortableElement = le),
    (e.SortableHandle = $),
    (e.sortableHandle = $),
    (e.arrayMove = function(e, t, n) {
      return (
        (e = e.slice()).splice(n < 0 ? e.length + n : n, 0, e.splice(t, 1)[0]),
        e
      );
    }),
    Object.defineProperty(e, '__esModule', {value: !0});
});
